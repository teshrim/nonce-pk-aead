\paragraph{Comparison with BT.}
\tsnote{This should be revisited once we get a full and current version from Mihir.}

\emph{Why does decryption take $\pubiv,\header$ as input?} For applications like public-key-based keywrapping (and key transport?) the public-AD~$\header$ provides context to the receiver about the decrypted data. (See comments above)  Providing $\pubiv$ enables mechanisms for preventing replay.  \task{Example, other things?}  The downside is that, in some settings, exisiting decryption APIs may need to be updated.  BT explicitly did not require decryption to take $\pubiv,\header$ for just this reason.

\emph{In BT the ``seed'' seems to play the same role as the secret AD.}  To a point, yes, although our separation of the secret-AD into recoverable and unrecoverable components (one or both of which may be empty) allows for things like private metadata.  BT encapulates the seed-production algorithm as part of the syntax of an encryption scheme.  We externalize this (see below), although it isn't clear there's a big difference here.

Looking ahead, our security notions are pretty different. The BT definitions treat the seed as a generated-once (per lifetime of public-secret key pair) client-side secret.  This seed is used for every encryption, hence is independent of the message or any per-message context.  Thus our definitions treat the ``seed'' differently, and this motivates a different semantic (server-side secret vs.\ per-message metadata), even though the encryption algorithm syntax is essentially the same.  Note that our two-part secret-AD is a strict generalization of BT, since (as we will see in a moment) the production of~$(\umd,\rmd)$ is stateful; this allows for a fixed value after the initial state. \tsnote{BT's nonce-generator and our secret-AD production algorithm have very similar APIs too.  But he gives no motivation for motivation his input~$X$, which he calls the ``nonce selector'' ($\nu$ in his notation).}
