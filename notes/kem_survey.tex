\documentclass[11pt, pdftex]{article}
\usepackage{epsf}
\usepackage{epsfig}
\usepackage{times}
\usepackage{ifthen}
\usepackage{comment}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[margin=1in]{geometry}
\usepackage{url}


\title{KEM Styles}
\author{}
\date{}


\begin{document}
\maketitle

\section{Definitions}

\subsection{KEM}
Design and Analysis of Practical Public-Key Encryption Schemes Secure against Adaptive Chosen Ciphertext Attack (CS, SIAM JoC 2003)
\begin{itemize}
\item $KeyGen(\lambda) \$\rightarrow (PK, SK)$
\item $Enc(\lambda, PK) \$\rightarrow (K, \psi)$
\item $Dec(K, SK, \psi) \rightarrow K \text{ or } \perp$
\end{itemize}

\subsubsection{Security Game}
\begin{enumerate}
\item Adversary receives the public key $PK$
\item Adversary queries a decryption oracle (note enc can be run locally with $PK$)
\item Adversary is given access to an encryption oracle that either (0) returns a random key with a ciphertext or (1) returns a key and encrypted version of that key under the KEM encrypt algorithm.  $K$ is generated from coins internally, not specified by the adversary.
\item Adversary has access to the decryption oracle but may not query ciphertexts returned by the encryption oracle
\item Adversary must return a bit distinguishing random keys from KEM produced keys
\end{enumerate}

\subsection{tag-KEM/DEM} 
Tag-KEM / DEM : A New Framework for Hybrid Encryption (AGKS, EUROCRYPT 2005)
\begin{itemize}
\item $KeyGen(\lambda) \$\rightarrow (PK, SK)$
\item $Key(PK) \$\rightarrow (\omega, dk)$
\item $Enc(\omega, \tau) \$\rightarrow (\psi)$
\item $Dec(SK, \psi, \tau) \rightarrow dk \text{ or } \perp$
\end{itemize}

\subsubsection{Security Game}
\begin{enumerate}
\item The game creates a public/secret key pair $PK,SK$, a random key $dk_0$ and a KEM created key and encryption information $dk_1,\omega$
\item Adversary receives $(PK, dk_{\sigma})$ and NOT $\omega$
\item The adversary gets to query a decryption oracle before generating a tag $\tau$ and some random state $\rho$
\item The challenge ciphertext is generated with $\omega$ and $\tau$
\item The Adversary is given $\rho$ and the challenge ciphertext $\psi$ and access to a decryption oracle that cannot be given $\psi$.  The adversary chooses whether the original key was randomly generated or created by the KEM
\end{enumerate}

\subsection{AKEM}
Constructing Secure Hybrid Encryption from Key Encapsulation Mechanism with Authenticity (SS, Cryptography and Coding 2011)
\begin{itemize}
\item $KeyGen(\lambda) \$\rightarrow (PK, SK)$
\item $Key(PK) \$\rightarrow (K, e)$
\item $Enc(e, ad) \$\rightarrow (\phi)$
\item $Dec(SK, \phi) \rightarrow (K, vr) \text{ or }\perp$
\item $Vrfy(vr, ad) \rightarrow \{0,1\}$
\end{itemize}

\subsubsection{IND-f-CCA}

\begin{enumerate}
\item The game creates a public/secret key pair $(PK,SK)$, a random key $K_0$ and a KEM created key and encryption information $K_1,e^*$
\item The adversary given $PK,K_b$ and a decryption oracle generates $(ad^*, st)$
\item The challenge ciphertext $\phi^*$ is generated with $e^*$ and $ad^*$
\item The Adversary is given $(st, \phi^*)$ and access to a decryption oracle that cannot be given $\phi^*$.  The adversary chooses whether the original key was randomly generated or created by the KEM
\end{enumerate}

Given access to a Dec oracle, the adversary gets to specify the associated data $ad^*$ in the first phase and must determine if a challenge key is contained in the challenge ciphertext or if it was randomly generated.  Here, $f$ is an arbitrarily chosen function that takes $K$ and some value $w$ and returns associated data $ad$.  The Dec oracle works as follows:

On input $(\phi,w)$, it computes $Dec(SK,\phi) = (K,vr)$ and $f(K,w) = ad$.  It returns $K$ if $Vrfy(vr, ad) = 1$, otherwise it returns $\perp$

\subsubsection{IND-f-aCCA}

Matches the setting above, except the stage two adversary is given a challenge ciphertext and must determine if the $ad$ used to encrypt it
was randomly generated or generated by the stage 1 adversary.  There is only one challenge $(K^*,e^*)$ pair in this setting, generated by the KEM.

\subsubsection{UF-f-CCA}

Given a challenge key $K^*$ and encryption information $e^*$, the first stage adversary 
selects associated data $ad^*$ which is used to make the challenge ciphertext $Enc(e^*,ad^*) = \phi^*$.  
The second stage adversary must forge a value $w'$ such that $f(K^*,w') = ad'$ and $Vrfy(vr^*,ad') = 1$

\subsection{signcryption-KEM} 
On the Connection Between Signcryption and One-pass Key (GBN, CCaC 2007)
\begin{itemize}
\item $CommonKeyGen(\lambda) \$\rightarrow params$
\item $KeyGen(params) \$\rightarrow (PK, SK)$
\item $Enc(params, SK_s, PK_r) \$\rightarrow (K, C)$
\item $Dec(params, SK_r, PK_s, C) \rightarrow K \text{ or }\perp$
\end{itemize}

In all security games, the adversary gets to access four oracles: Encapsulation, Decapsulation, 
Open (reveals random coins), and Corrupt (reveals a user's private key)

\subsubsection{Insider confidentiality}

Adversary selects $(pk_s,pk_r)$ from the pool of participants and is given a challenge 
$K_b, C^*$ and must determine if the key is random or generated by the KEM.  
The rules state the adversary cannot corrupt the receiving party, and it may either call 
Open on the challenge ciphertext or corrupt the sender, but not both. 

\subsubsection{Outsider confidentiality}

Matches insider confidentiality except that the adversary may not corrupt the sender ever.

\subsubsection{Unforgeability}

The adversary tries to create a forged $K^*, C^*$ under uncorrupted sender and receiver keys 
(that he chose from the pool of participants), where $K^*, C^*$ was never output by the encapsulation oracle.

\subsection{Signcryption tag-KEM} 
Building Better Signcryption Schemes with Tag-KEMs (BD, PKC 2006)
\begin{itemize}
\item $Com(\lambda) \$\rightarrow I$
\item $Key_s(I) \$\rightarrow (PK_s, SK_s)$
\item $Key_r(I) \$\rightarrow (PK_r, SK_r)$
\item $Sym(PK_r, SK_s) \$\rightarrow (\omega, K)$
\item $Encap(\omega, \tau) \$\rightarrow E$
\item $Decap(SK_r, PK_s, E, \tau) \rightarrow K \text{ or }\perp$
\end{itemize}

\subsubsection{Security Game}
\begin{enumerate}
\item The game generates global params and keypairs for sender and receiver
\item The first stage adversary gets to query $Sym, Enc, Dec$ oracles and returns some $state_1$
\item The game computes $(K_0,\omega)$ using $Sym$, a random $K_1$, and a challenge bit $b$
\item The second stage adversary gets $state_1,K_b$ and the same three oracles, returning tag $\tau$ and $state_2$
\item The game produces the challenge encapsulation $Encap(\omega, \tau) = E$
\item The third stage adversary gets $E$ and $state_2$ and must guess $b$
\end{enumerate}
Note that the Sym and Enc oracle calls are tied together, as they store the parameter $\omega$ and do NOT reveal it to the adversary
This work also defines sUF-CMA security such that a tag encapsulation pair cannot be forged.  The restriction is that $E^*$ may
not have been returned by the encap oracle


\subsection{Signcryption tag-KEM 2} 
On the Security of Tag-KEM for Signcryption (YF, ENTCS 2007)
\begin{itemize}
\item $KeyGen(\lambda) \$\rightarrow (PK, SK)$
\item $Sym(PK_r, SK_s) \$\rightarrow (\omega, K)$
\item $SEncap(\omega, \tau) \$\rightarrow E$
\item $VDecap(SK_r, PK_s, E, \tau) \rightarrow K \text{ or }\perp$
\item \url{www.signcryption.org}
\end{itemize}

\subsubsection{Security Game}
Same as the previous definition

\subsection{signature KEM} 
Hybrid Signcryption Schemes with Insider Security (Dent, ISC 2005)
\begin{itemize}
\item $Gen(\lambda) \$\rightarrow (PK, SK)$
\item $Encap(SK, m) \$\rightarrow (K, C_1)$
\item $Decap(PK, m, C_1) \rightarrow K \text{ or }\perp$
\item In this scheme, $K$ is a MAC key, so the ultimate goal is to provide a hybrid signature scheme
combining public and symmetric key constructions for integrity and authentication.
\end{itemize}

\subsubsection{Security Game}
Security is informally described as the inability to produce a valid $C^*_1$ for any $K,m$ pair

\subsection{TLS LKEM} 
On the Security of the TLS Protocol: A Systematic Analysis (KPW, CRYPTO 2013)
\begin{itemize}
\item $KeyGen(\lambda) \$\rightarrow (PK, SK)$
\item $Enc(\lambda, PK, L) \$\rightarrow (K, \psi)$
\item $Dec(K, SK, \psi, L) \rightarrow K \text{ or } \perp$
\end{itemize}

\subsubsection{IND-CCCA (Constrained CCA)}
\begin{enumerate}
\item The game creates a public/secret key pair
\item The adversary gets $PK$ and queries a decryption oracle before generating a label $L^*$
\item The challenge ciphertext $C^*$ is generated with $L^*$
\item The Adversary is given $C^*$ and access to a decryption oracle that cannot be given $(L^*, C^*)$.  The adversary chooses whether the original key was randomly generated or created by the KEM
\item Note that the decryption oracle returns $\perp$ if the check (some internally defined predicate on $K,T$) on the queried label fails
\end{enumerate}

\section{Questions}
\begin{enumerate}
\item Why doesn't the predicate in IND-CCCA security take in the label $L^*$?
\end{enumerate}

\end{document}