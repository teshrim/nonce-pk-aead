%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Security notions for PK-AEAD} 
\subsection{Current notions}
Here we consider candidate security notions for an IV-based PK-AEAD scheme.  Fix a scheme $\pkaead=(\Kgen,\Enc,\Dec)$ with secret-AD space~$\metadata$, and a secret-AD generation algorithm $\mdalg$ outputting strings in~$\metadata$. \tsnote{Insert appropriate qualifications on $\mdalg$ once these are sorted out.} Let~$\advA$ be an adversary.  

In Figure~\ref{fig:pkaead-notions} we give a notion of privacy.  The adversary queries an oracle that, on input $(\header,\pubiv,M_0,M_1)$, returns the encrpytion of $(\seciv,M_b)$ where~$S$ is produced by executing $\mdalg(\st,M_b)$ with the its current state~$\st$, and~$b$ is the random challenge-bit.  In this notion, we assume that $|M_0|=|M_1|$ in every query.

As previously noted, if the adversary controls~$\header, \pubiv$ and the plaintext messages, and encryption is deterministic, then the notion in Figure~\ref{fig:pkaead-notions} is unachievable if the secret-AD~$\seciv$ is predictable. Thus we introduce an auxillary notion, that of \textit{predictability of the secret-AD}.  Figure~\ref{fig:pred-notions} gives two possible formalizations.  On the left, the adversary sends plaintext strings~$X$ to an oracle~$\predOracle$ that executes $\mdalg(\st,X)$ on the current state~$\st$ and returns the resulting secret-AD~$\seciv$.  At the end of its execution, the adversary returns a state-message pair~$(T,M)$ and wins if the value $\mdalg(\st,M)$, executed with the current state, is the same as~$T$.  Essentially, for any sequence of adversarially chosen messages and the corresponding secret-AD strings, it should be hard to guess the next secret-AD value.\tsnote{The captures adversaries that can nudge applications into producing particular plaintexts, and can observe (but not corrupt) whatever is producing the secret-AD. } 

\tsnote{Unfortunately, I don't see how to align the previous definition with the setting where~$S$ is (say) a user's password.  What follows is a rough attempt capture this with a simulation-based definition... but it isn't quite right yet.}  On the right, we give a formalization that is simulation-based.  The function~$\phi\colon\ptxts\to\bits^*$ determines how plaintext information is leaked to the simulator.  In other words, how much one needs to know about plaintexts in order to properly simulate secret-AD production.  This captures what about the plaintext is actually used to determine the secret-AD. For example, if $\phi(X)=X$ is required for an efficient simulator to fool the adversary, then secret-AD production must depend on all of the bits of each plaintext.  If $\phi(X)=|X|$ suffices, then only the length matters.  When $\phi(X)=\emptystring$ suffices, we capture settings where the secret-AD is independent of plaintext bits, e.g.\ when~$\seciv = H(\mathrm{salt} \concat \mathrm{pwd})$, or when~$\seciv$ is a message counter.


Our defintions are actually pretty different that Mihir's.  He has (potential) per-message nonce-generation, and a one-time secret nonce (``seed'').  The adversary does not get to see the nonce, but does got to influence it's choice though the ``nonce selector''.  Our definition give control of the nonce to the adversary, and has (potential) per-message secret nonce (i.e. secret-AD).  I'm not sure how his and our definitions relate.

\begin{figure}
\begin{center}
\fpage{.5}{
\hpagess{.425}{.55}{
 \underline{$\ExpINDCDA{\kreg,\mdalg,\pkaead}{\advA}$}:\\[2pt]
 $(\pk,\sk)\getsr\Kgen(\kreg)$\\
 $\st \getsr \mdalg(\emptystring,\bot)$\\
 $b\getsr\bits$\\
 $b'\getsr\advA^{\encOracle}(\pk)$\\
 Return $[b'=b]$\\
}
{ 
\Oracle{$\encOracle(\header,\pubiv,M_0,M_1)$}:\\[2pt]
 $(\st,\seciv) \getsr \mdalg(\st,M_b)$\\
 Return $\Encprim{\pk}{\header,\pubiv}{S,M_b}$\\[40pt]
}
}
\caption{Privacy notion for an IV-based PK-AEAD
  scheme~$\pkaead$.  Secret-AD is produced by~$\mdalg$.  The key-pair
  is produced using registration-data~$\kreg$.} 
%\task{Our PRED notion is essentially the same as Mihir's PRED notion.  How
%  does he use it in his proofs?}\tsnote{He uses it in the ROM to show how to build a hedged extractor with RoR-security.  This allows the PRED adversary in the RoR-reduction to simply return random strings and to ``guess'' which of the RO-queries is the one containing the output needed to win the PRED game.  We can't do that here, even in the ROM, as far as I can see.}
\label{fig:pkaead-notions}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\hfpagess{.25}{.25}
{
 \underline{$\ExpPred{\mdalg}{\advP}$}:\\[2pt]
 $\st \getsr \mdalg(\emptystring,\bot)$\\
 %$ Q \gets \emptyset$\\ 
 $ (T,M)\getsr\advP^{\predOracle}$\\
 %Return $[S' \in Q ]$
 $ (\st,\seciv) \getsr \mdalg(\st,M)$\\
 Return $[S=T]$

\medskip
 \Oracle{$\predOracle(X)$}:\\[2pt]
 $(\st,\seciv) \getsr \mdalg(\st,X)$\\
 Return~$S$
 %$Q \gets Q \cup \{\seciv\}$\\
}
{
\underline{$\ExpPred{\mdalg,\simulator,\phi}{\advP}$}:\\[2pt]
$b \getsr \bits$\\ 
$\st \getsr \mdalg(\emptystring,\bot)$\\
$\st' \gets \st$ (or maybe $\st'\gets\emptystring$?)\\
$ b'\getsr\advP^{\predOracle}$\\
 Return $[b'=b]$ 

\medskip
 \Oracle{$\predOracle(X)$}:\\[2pt]
 if $b=1$ then\\$(\st,\seciv) \getsr \mdalg(\st,X)$\\
 else $(\st',\seciv) \getsr \simulator(\st',\phi(X))$\\
 Return~$S$
 %$Q \gets Q \cup \{\seciv\}$\\
 }
\caption{ {\bf Left:} Unpredictability notion for secret-AD algorithm~$\mdalg$. {\bf Right:} Another potential predictability notion, this one simulation-based.}\tsnote{Here we can support things like $\seciv$ being a sampled-once string like a user password.}  
\label{fig:pred-notions}
\end{center}
\end{figure}

\subsection{Older notions}
Here we consider candidate security notions for an IV-based PK-AEAD scheme.  Fix a scheme $\pkaead=(\Kgen,\Enc,\Dec)$ and a randomized algorithm~$\advD$ that samples from the secret-IV set~$\secivs$ (of $\pkaead$) according to some distibution.  Let~$\mu_\advD$ be the min-entropy of this distribution.  Let~$\advA$ be an adversary.  

In Figure~\ref{fig:ind-cda} we give two notions of plaintext privacy.  In the first, the adversary queries an oracle that, on input $(\header,\pubiv,M_0,M_1)$, returns the encrpytion of $(\seciv,M_b)$ where~$S$ was previously sampled by~$\advD$, and~$b$ is the random challenge-bit.  In this notion, we assume that $|M_0|=|M_1|$ in every query and that~$\advA$ is \emph{nonce-respecting}, meaning that it never repeats a value of~$\pubiv$ across its queries.  We refer to this as the Priv security notion.
In the second notion, the adversary does not control the value of~$\pubiv$.  Instead, when~$\advA$ queries $(\header,M_0,M_1)$, a fresh public-IV~$\pubiv$ is sampled from the public-IV set~$\pubivs$.  The oracle returns~$\pubiv$ along with the encryption of $(S,M_b)$ using that particular public-IV.  We refer to this as Priv-IV security notion.

In practice, security with respect to the first notion means that the PK-AEAD scheme will protect plaintexts so long as the calling environment provides nonces for the IVs, e.g. a reliable counter value.  Security with respect to the second notion means that the PK-AEAD scheme guarantees privacy only when the calling environment provides IVs that are random and independent across calls.

\tsnote{There are other verions, too, that might make sense.  In one, $S\getsr\advD$ not once, but each time the oracle is queried.  There's no need for nonce respecting behavior then.  In another, the adversary can decide whether or not a new~$\seciv$ is sampled on a query, and it must be nonce-respecting for a given~$\seciv$.  An ``$\seciv$-adaptive version of this would allow~$\advA$ to refer to sampled values of~$\seciv$ by handles and arbitrarly interleave queries to handles.}

For these two notions, we define corresponding advantage measures for a given adversary~$\advA$, sampler~$\advD$, and scheme $\pkaead$ as
\begin{align*}
\AdvINDCDA{\pkaead}{\advD,\advA}&=2\Prob{\ExpINDCDA{\pkaead}{\advD,\advA}=1}-1\\ \AdvINDCDAR{\pkaead}{\advD,\advA}&=2\Prob{\ExpINDCDAR{\pkaead}{\advD,\advA}=1}-1
\end{align*}
respectively.  In both experiments, we track the following adversarial resources: (1) the time-complexity~$t$ of~$\advA$, relative to some understood model of computation; (2) the query-complexity~$q$, measured as the number of queries made by~$\advA$ to its oracle; (3) the total query-length~$\sigma$, defined the be the sum over all query lengths, where $|(\header,\pubiv,M_0,M_1)|=|\header|+|\pubiv|+|M_0|$.
\begin{figure}
\begin{center}
\fpage{.5}{
 \hpagess{.425}{.55}{
 \underline{$\ExpINDCDA{\pkaead}{\advD,\advA}$}:\\[2pt]
 $(\pk,\sk)\getsr\Kgen$\\
 $b\getsr\bits$\\
 $S\getsr\advD$\\
 $b'\getsr\advA^{\encOracle(\cdot,\cdot,\cdot,\cdot)}(\pk)$\\
 Return $[b'=b]$\\

\medskip
 \underline{$\ExpINDCDAR{\pkaead}{\advD,\advA}$}:\\[2pt]
 $(\pk,\sk)\getsr\Kgen$\\
 $b\getsr\bits$\\
 $S\getsr\advD$\\
 $b'\getsr\advA^{\encOracle(\cdot,\cdot,\cdot)}(\pk)$\\
 Return $[b'=b]$

 }
 {
 \Oracle{$\encOracle(\header,\pubiv,M_0,M_1)$}:\\[2pt]
 Return $\Encprim{\pk}{\header,\pubiv}{S,M_b}$\\[51pt]

\medskip
 \Oracle{$\encOracle(\header,M_0,M_1)$}:\\[2pt]
 $N \getsr \pubivs$\\
 $C \gets  \Encprim{\pk}{\header,\pubiv}{S,M_b}$\\
 Return $(N,C)$

 }
}
\caption{Privacy notions for an IV-based PK-AEAD scheme~$\pkaead$ with public-IV and secret-IV sets $\pubivs,\secivs$ (resp.)}
\label{fig:ind-cda}
\tsnote{Doesn't match current syntax, where $\Kgen$ takes AD as input.  Need to think about how to handle this in the security notion(s).}
\end{center}
\end{figure}


\tsnote{Need authenticity notions.}