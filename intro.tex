\section{Introduction}
\label{sec:intro}
We introduce a new primitive, that of IV-based (deterministic) public-key authenticated-encryption with support for public and secret associated data.  Very quickly, to encrypt plaintext~$M$ and private-AD~$(\umd,\rmd)$, under public-key~$\pk$, with public-AD~$\header$ and public-IV~$\pubiv$, we write $C\gets\Encprim{\pk}{\header,\pubiv}{\umd,\rmd,M}$.\tsfnote{To encrypt long plaintexts~$M$, one likely uses a KEM-DEM construction (with a deterministic KEM) to instantiate the primitive.  This is discussed in the body.}
The secret-AD component~$\rmd$ is ``recoverable'' in the sense that, upon successful decryption of~$C$, the pair~$(\rmd,M)$ is returned by decryption.  The secret-AD component~$\umd$ is ``unrecoverable'' in the sense that it is never released by decryption.  Loosely speaking, $\umd$ is meant to be consumed within the abstraction boundary of decryption, e.g., to support authentication.  In order to leverage this, the receiver would need to keep some state~$\auxinput$ that is passed in to the the decryption call.  We write the operation or decryption as $\Decprim{\sk}{\header,\pubiv}{C,\auxinput}$, this returning $\bot$ if the~$\umd$ contained within~$C$ is invalid for the receiver-side~$\auxinput$, and returning $(\rmd,M)$ otherwise.

\paragraph{Applications. }
Let us give some potential applications of this primitive, and motivate the various inputs to encryption and decryption.
\tsnote{Just a collection spot. Some things already incorporated into the body.}
\begin{itemize}
\item Web applications: if the server already stores $Z=\langle \mathrm{salt},H(\mathrm{salt}\concat \mathrm{pwd})\rangle$ for a user, then this can be used, with $\umd=\mathrm{pwd}$, to enable password-based authentication.  Likewise, if the server is willing to keep some additional state for the user, then~$\pubiv$ can help to prevent replay.  (I wonder if IV-based PK-AEAD might be useful for reduced latency in resuming web sessions, etc.)
%
\item Traffic analysis: maybe one wants to hide the ordering of messages, i.e. ``this is the third message in a stream", because this gives something away to an observer.  While a public counter/nonce would give this away, a secret counter/nonce would not.  So, maybe the public-IV~$\pubiv$ tells you that this is the third ciphertext in a stream, but the (recoverable) secret-AD~$\rmd$ tells you the actual ordinality of the plaintext.  This is one of the motivations, I believe, for the explicit public and secret message number in the call for CAESAR submissions.  (The idea appears implicitly in David McGrew's RFC 5116 ``An Interface and Algorithms for Authenticated Encryption", which predates CAESAR.)  Think also about providing TCP-like functionality over UDP, but without exposing the higher-level reconstruction information on the wire.
%
\item IoT: Are there settings in which the public key of a central server has been pre-deployed to many ``users", but those users do not have reliable sources of randomness? I'm thinking IoT kinds of settings where a manufacturer may have installed a master public key on many embedded devices that do not have quality sources of randomness, but can keep a counter.  The counter need not be specifically for encryption, just something that could be co-opted for the purpose.  Perhaps there's no randomness source at all, but each device has a device ID that was burned in at the manufacturer, and thus can serve as a value with some amount of min-entropy.  In this case, we might have $\umd$ as the device ID (and $\auxinput$ as data sufficient to validate this ID), and $\rmd$ as the device state at the time plaintext~$M$ was sent.  When $(\rmd,M)$ are returned, the receiver can use the recovered~$\rmd$ to help make additional decisions about the reliability of~$M$ or the device itself.
%
\item Network stacks: it's possible, even likely in some settings, that the public-IV~$\pubiv$ and the secret-AD are provided by different entities.  The secret-AD may come from the application layer, perhaps without the application's user knowing it, while the public IV comes from the transport/network layer. (I'm not naming any particular application here, just pointing out that modern stacks may be doing this already in some ad-hoc fashion.)  The application layer can use $\umd$ and/or $\rmd$ to provide entropy or counters to protect itself against bad or low-quality randomness or nonce-generation lower in the stack where encryption is actually performed.
%
\item Provenance: $\rmd$ as secret metadata about the plaintext, the application that produced it, a snapshot of the operating system at the time that the plaintext was produced, etc. \tsnote{Talk to Kevin, Adam}
%
\item Onion/Garlic-routing schemes: ... ? \tsnote{I2P uses a ``garlic-routing'' scheme whose route establishment seems to be supported by our syntax.  Don't know about others.}

\end{itemize}
